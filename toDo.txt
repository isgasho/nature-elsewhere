Develop Nature Elsewhere into a complete, beautiful, iconic, fun, intuitive, simple, detailed, finely built game with tremendous colors.
  Make large, lavish, content-rich levels.
    Complete one level. The goal is to identify and solve any infrastructure requirements and architectural complexities, and eliminate ambiguities that require deep consideration. The idea is that if one level is technically feasible and fun, the whole game is a worthwhile inevitability, not just a possibility, given hard work.
      Seeing the game with new eyes, what are the biggest obstacles to maximal enjoyment? What would I change if I rewrote it from scratch? How can it be simpler, more delightful, polished, toothy and pixely, tight.
      Add options UI.
      Add pause level.
      Improve the title screen and Nature Elsewhere logo. The opening needs to pop.
      Make the level editor more featureful.
        Add scale and velocity fields. I think I need to expose a generic property bag. Maybe remove x and y fields--these seem less useful.
        Allow state and variant changes of selected entity.
        Improve the level editor menu.
        Pan on click and "dragging the plane" rather than clicking outside the deadzone.
        Allow the editor to jump in and out of play mode (must reset state when going back to edit mode).
        Encapsulate the marquee API / sandbox / panel API in general.
        Import and export entire levels, not just the entities.
        Allow changing level properties like minViewport, cam position, player position, and plane.
        Always drop entities in the center of screen or, better, make some kind of drag and drop interface.
        Is a post-inflation lifecycle useful beyond on the panel? The panel would benefit from it to find the sandbox and load the entities.
        Add a die button for setting a random variant.
        Figure out a way to signal 1) entities offscreen and 2) fully overlapped entities.
        Add undo and redo buttons.
          Make editor support commands.
        Increase and decrease arrows are confusing. Increase is down and decrease is up, for example.
        The buttons are pretty far away from their selector knobs. How can this be improved?
      Add game over / continue screen / loop.
      Add next level portal.
      Improve the backpacker.
        How can the contrast with water be improved? Will water traversal be permitted?
        How can the animations be improved? They were made pretty haphazardly but now maybe that can be reevaluated.
        How can the sprite be improved? What other visuals can be considered? Does it fit the theme? Is it compelling enough for an avatar?
        Can it be made accessorizable? At least coloring?
      Improve the palette. Tremendous colors!
        I think that shade of blue in particular isn't quite right. I need a deep lake blue and couple extra values. Most probably lots of tweaking is needed.
        The cursor probably needs a unique color like the shadows.
      Improve the level editor and toolbelt / toolbar UI. Shift a little more towards ornate or intricate. It should be delightful and intuitive! I love the Diablo globes but maybe with even more saturated colors.
        Start with a highly detailed mock.
        Maybe a big heart bar or health globe.
        Can I use the old inverse kinematic JS code?
        UI should be easy to use on mobile.
        What would a Myst / Diablo crossover look like?
      Add inventory management.
        Start with a highly detailed mock.
        Add "a summary of you" / inven / journal screen level.
        Add more items to gather like artifacts and animal byproducts like bee stingers.
        Consider minimap.
        Can encumber code be used? What about other projects?
        I think collecting, XP, and HP, could be major parts of the game. I love the Diablo II horadric cube, and RE4 and Symphony of the Night inventory management. Maybe Diablo meets Solar Jetman meets Earthbound.
----> Add gameplay. How codes combat and inventory work?
        Mock out some bee hunting and interactions in great detail. Review past mocks, inspirado, and the old notes. What's a fun design?
        What should the enemies be?
        Maybe favor straight line moving.
        I like the idea of auto-attacking but also ammo conservation. If auto-range attacks exist, they should be opt-in.
        Maybe you attack by touching enemies at diagonally. Does it work on mobile?
        Are there ranged attacks like bow and arrows?
          It would be neat if arrows stuck in the ground or scattered and emitted a little cloud of dust on impact. Arrows should make a dumb little sound when shot.
        Maybe hover text for hit points.
        Consider restoring parts of old input system, including virtual joystick, as needed but keep in mind the lowest common denominator. Escape and Android back support are needed, and editor and debug shortcuts might be nice.
        Do I need A*?
      Make many wonderful entities.
        Add tornados.
        Add lightning to the cloud entity.
        Add cactus.
        Add more clouds.
        Add pond shader.
        Add rainbow.
        Add waterfall.
        Add more water.
        Add quicksand.
        Add more trees.
        Add Storymaker bubble egg.
        Fade out the destination maker and allow a few instances. Maybe reverse the animation.
------->Improve the grass clumps. The mocks seem a lot nicer. Maybe just make them all shorter? Try perspective.
------->Improve grass patches. These are currently path hacks and should be nicer.
        Check that the entities have strong, even, isometric perspectives.
        I need a better way to manage states and transitions.
          ImageStateMachine doesn't really do anything. It has a state and then then the images for each state. Maybe this should move back to entity to limit all the invalidation walking.
          There's some great examples of how to do player states, FSMs, and collision detection / gravity in https://script-8.github.io/?id=a3b40a159db3c794c1024fba73f4eb99.
          There's some good examples in Underrun too. E.g., the Entity class: https://github.com/phoboslab/underrun/blob/master/source/entity-sentry.js, kontra.js, impact.js.
        I need a better way to manage inter-entity and inter-level communication.
          What are my current needs? There are currently lots of communications with cursor, marquee, and panel. What about some common interactions like collision or parent to child or the update termination? These all kind of suck right now.
        How can I make the entity serializer / differ thing a less clunky? Can I expose defaults instead of toJSON() and the let the serializer pull that?
        Entities need to respect level boundaries better.
        Add versions to configs.
        Do I need different collision body states? It seems like a good deal of the time I don't want this with the notable exception of maybe on death but hopefully I can just change the collision type. For example, DEAD_BODY.
        Is there a bug when an active entity on the screen boundary collides with an inactive entity just off screen? Maybe any entity that is active, recursively activates all other entities they touch? I'm not quite sure how htat works.
        How can the entity type be simplified technically and in presentation?
          The entities are quite complex at the moment. They have a ton of state, rectangles especially. Each entity can have multiple collision bodies, images, variants, states, and children recursively.
          How can I improve rectangle / recursive coordinate system management?
          Statically defining variants and states doesn't seem ideal.
          What constraints can we set? Max images? Max size? Max children?
        Adding collision bodies is back to manual now. Is it easy to set them for all cels?
        Can collisions test and resolve within update? I think the testing is, it's just kind of convoluted.
        Reevaluate recursive collision and movement system.
          How should notifications work? I could also use a notify ID system for collision resolution instead but then IDs have to be unique which isn't bad. Might be nice instead of the hierarchy which is a little strange. Do I want this lookup over recursion? I could present and size by single entity only then!
        This decamillipixel nonsense is confusing. It's like .1px/s but everything is .6px/s or more. Is the half pixel needed? Millipixel would be a lot nicer. This would be more forgiving for the shader shorts. What's going on in vertex.glsl?
        Maybe base Entity should support targeting. Entities often have a destination.
        Consider alternative rain shader patterns.
        Develop entity behaviors (AI) more. The circle bee behavior might be a good starting point.
        Add some kind of unstoppable giant monster / colossus / death entity.
        The s/getter syntax is terser but isn't very flexible compared to functions: 1) no support for multiple parameters 2) types must match 3) creates ambiguity with functions 4) for better and worse, allows implicit conversions via duck typing. Should I change them to functions?
  Synthesize fantastic sounds.
    Understand the basics: https://news.ycombinator.com/item?id=20272346
    Rename audio player to speaker or something.
    Flesh out the audio system.
      Synthesize crickets, wind, rain, thunder, and birds.
    Survey all the demos in Super Collider.
    Probably pursue lofi.
  Improve the structure. Write little, clearly.
    What TypeScript and other open source examples should I consider?
    Re-review WebGL implementations.
  Add windy grass displacement shader to make the fields pop.
    Maybe look through shader toys and displacement shader 101s.
      https://forums.tigsource.com/index.php?topic=40539.20
      https://www.austinobrien.me/blog/shader-study/slime-rancher-pixel-display
    Add shadow distortion shader too.
    Do I need a shader for better types of water? What does it look like?
  How can I move my planning materials into the VCS?
  Review Diablo tile IDs: https://www.boristhebrave.com/2019/07/14/dungeon-generation-in-diablo-1/
  Improve favicon.
  Add performance test level.
  Add test for newing each entity variant.
  Set up natureelsewhere.com GitHub page. Point to demo at ne.netlify.com.
  Set up oddoid.com GitHub page. Point to natureelsewhere.com and other projects.
  Evaluate fixing known issues in readme.
    If I drop WebGL v2, drop @types/webgl2.
  What examples are there for making 9png like UI?
    Check out 9pngs / 9patch and svgs like https://twitter.com/rchrdnsh/status/1155163594264203264  https://thebookofshaders.com/09/
  Research videos and articles by the experts like GDC.

aseprite-atlas
  Reconsider JSON serialization of infinite duration. If a special value like null or not present is used, either a parser for the parsed output or conditionals all over is needed.
  Keep thinking on OO tradeoffs.
mem-font
  Push mem-font changes upstream and rework project.
oddoid
  Keep thinking on names.
