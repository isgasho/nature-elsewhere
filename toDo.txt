Develop Nature Elsewhere into a complete, beautiful, iconic, fun, intuitive, simple, detailed, finely built game with tremendous colors.
  Make large, lavish, content-rich levels.
    Complete one level. The goal is to identify and solve any infrastructure requirements and architectural complexities, and eliminate ambiguities that require deep consideration. The idea is that if one level is technically feasible and fun, the whole game is a worthwhile inevitability, not just a possibility, given hard work.
      Seeing the game with new eyes, what are the biggest obstacles to maximal enjoyment? What would I change if I rewrote it from scratch? How can it be simpler, more delightful, polished, toothy and pixely, tight.
      Add options UI.
      Add pause level.
      Improve the title screen and Nature Elsewhere logo. The opening needs to pop.
      Make the level editor more featureful.
        Add scale and velocity fields. I think I need to expose a generic property bag. Maybe remove x and y fields--these seem less useful.
        Allow state and variant changes of selected entity.
        Improve the level editor menu.
        Pan on click and "dragging the plane" rather than clicking outside the deadzone.
        Allow the editor to jump in and out of play mode (must reset state when going back to edit mode).
        Encapsulate the marquee API / sandbox / panel API in general.
        Import and export entire levels, not just the entities.
        Allow changing level properties like minViewport, cam position, player position, and plane.
        Always drop entities in the center of screen or, better, make some kind of drag and drop interface.
        Is a post-inflation lifecycle useful beyond on the panel? The panel would benefit from it to find the sandbox and load the entities.
        Add a die button for setting a random variant.
        Figure out a way to signal 1) entities offscreen and 2) fully overlapped entities.
        Add undo and redo buttons.
          Make editor support commands.
        Increase and decrease arrows are confusing. Increase is down and decrease is up, for example.
        The buttons are pretty far away from their selector knobs. How can this be improved?
      Add game over / continue screen / loop.
      Add next level portal.
      Improve the backpacker.
        How can the contrast with water be improved? Will water traversal be permitted?
        How can the animations be improved? They were made pretty haphazardly but now maybe that can be reevaluated.
        How can the sprite be improved? What other visuals can be considered? Does it fit the theme? Is it compelling enough for an avatar?
        Can it be made accessorizable? At least coloring?
      Improve the palette. Tremendous colors!
        I think that shade of blue in particular isn't quite right. I need a deep lake blue and couple extra values. Most probably lots of tweaking is needed.
        The cursor probably needs a unique color like the shadows.
      Improve the level editor and toolbelt / toolbar UI. Shift a little more towards ornate or intricate. It should be delightful and intuitive! I love the Diablo globes but maybe with even more saturated colors.
        Start with a highly detailed mock.
        Maybe a big heart bar or health globe.
        Can I use the old inverse kinematic JS code?
        UI should be easy to use on mobile.
        What would a Myst / Diablo crossover look like?
      Add inventory management.
        Start with a highly detailed mock.
        Move collected items to inventory instead of just deleting them from the level.
        Add "a summary of you" / inven / journal screen level.
        Add more items to gather like artifacts and animal byproducts like bee stingers.
        Consider minimap.
        Can encumber code be used? What about other projects?
        I think collecting, XP, and HP, could be major parts of the game. I love the Diablo II horadric cube, and RE4 and Symphony of the Night inventory management. Maybe Diablo meets Solar Jetman meets Earthbound.
----> Add gameplay. How codes combat and inventory work?
        Something like Diablo with immunity on diagonal attacks. Tap on the enemy for improved damage. Automatically melee if in range _and_ hostile? How does one not attack? It's unclear what the melee weapon should be. Arrows should be fired automatically at enemies if equipped and not moving?
        Gameplay AND art constraints inform structure of code, Aseprite files, etc.
        Mock out some bee hunting and interactions in great detail. Review past mocks, inspirado, and the old notes. What's a fun design?
          Review materials, synthesize and write tiny plans, do each plan.
          What would mocking out a whole scene from scratch now look like?
        What should the enemies be?
        Maybe favor straight line moving.
        I like the idea of auto-attacking but also ammo conservation. If auto-range attacks exist, they should be opt-in.
        Maybe you attack by touching enemies at diagonally. Does it work on mobile?
        Are there ranged attacks like bow and arrows?
          It would be neat if arrows stuck in the ground or scattered and emitted a little cloud of dust on impact. Arrows should make a dumb little sound when shot.
        Maybe hover text for hit points.
        Consider restoring parts of old input system, including virtual joystick, as needed but keep in mind the lowest common denominator. Escape and Android back support are needed, and editor and debug shortcuts might be nice.
        Do I need A*?
      Make many wonderful entities.
        Add tornados.
        Add grasshopper.
        Add lightning to the cloud entity.
        Add cactus.
        Add more clouds.
          Should the clouds dump long sloppy streams of water or pitter-patter? Some mocks on this in mock-encounter.aseprite and garfbage.aseprite and probably elsewhere.
        Add pond shader.
        Add rainbow.
        Add fire. See tileset-big.ase.
        Add multi-eyed beast.
        Add cemetary.
        Add waterfall.
        Add birds that can float over the landscape like clouds. Example in mock.aseprite.
        Add streams. Example in mock.aseprite.
        Add warning monuments. Examples in mock.aseprite and tileset-big.ase.
        Add more water.
          Improve pond water effect.
        Add quicksand.
        Add more trees.
          Starting with the tree skeleton is great and may help parametrize content later
          Draw the large tree in perspective. There's a shadow demo in garfbage.aseprite.
        Maybe draw sandtraps as obstacles.
        Add dead logs.
        Add lighthouse or windmill?
        Add tree stumps.
        Add some super saturated and connected clumps of grass. Some examples in grassss.aseprite.
        Add teleport.
        Add more "errant" textures to each image like little single pixels of grass.
        Try a baseline grass texture again just to see what it adds. Example in map5.aseprite.
        Review stained glass (there are at least two big circles) in tileset-big.ase.
        Add brain and frozen brain. See tileset-big.ase.
        Add duck? See mock-utility-belt.aseprite.
        Add skeleton? See mock-utility-belt.aseprite.
        Add ooz tube and gore fountain. See rubbish.aseprite.
        Add well. See rubbish.aseprite.
        Add Storymaker bubble egg.
        Improve the level boundaries. Maybe leaves or trees.
        Decide on clovers or reduce their size. Can I add more of the micro-flowers like in the old old mocks instead?
        Do I want to better distinguish the backpacker from the background? For example, in front of water the colors are identical.
        Add more flowers but try to put them in perspective.
        Fade out the destination maker and allow a few instances. Maybe reverse the animation.
        Improve grass patches. These are currently path hacks and should be nicer.
        Check that the entities have strong, even, isometric perspectives.
          Correct the path perspective. There's one that links up properly in mock-path.aseprite.
          There's some really nice golf course and level box perspectives in garfbage.aseprite. General perspective nots in rubbish.aseprite.
        I need a better way to manage states and transitions.
          ImageStateMachine doesn't really do anything. It has a state and then then the images for each state. Maybe this should move back to entity to limit all the invalidation walking.
          There's some great examples of how to do player states, FSMs, and collision detection / gravity in https://script-8.github.io/?id=a3b40a159db3c794c1024fba73f4eb99.
          There's some good examples in Underrun too. E.g., the Entity class: https://github.com/phoboslab/underrun/blob/master/source/entity-sentry.js, kontra.js, impact.js.
        I need a better way to manage inter-entity and inter-level communication.
          What are my current needs? There are currently lots of communications with cursor, marquee, and panel. What about some common interactions like collision or parent to child or the update termination? These all kind of suck right now.
        How can I make the entity serializer / differ thing a less clunky? Can I expose defaults instead of toJSON() and the let the serializer pull that?
        Entities need to respect level boundaries better.
        Add versions to configs.
        Do I need different collision body states? It seems like a good deal of the time I don't want this with the notable exception of maybe on death but hopefully I can just change the collision type. For example, DEAD_BODY.
        Do I want to support elevations the explorer can ascend like little dirt mounds, mountains, plateaus, and even buildings? What are the implications for htings like clouds, mount / dismount, gameplay and pathfinding, and others?
        Is there a bug when an active entity on the screen boundary collides with an inactive entity just off screen? Maybe any entity that is active, recursively activates all other entities they touch? I'm not quite sure how htat works.
        How can the entity type be simplified technically and in presentation?
          The entities are quite complex at the moment. They have a ton of state, rectangles especially. Each entity can have multiple collision bodies, images, variants, states, and children recursively.
          Should I pursue simpler, possibly fixed size, tiles rather than entity and layered image compositions? Maybe this could help the art?
          How can I improve rectangle / recursive coordinate system management?
          Statically defining variants and states doesn't seem ideal.
          What constraints can we set? Max images? Max size? Max children?
        Adding collision bodies is back to manual now. Is it easy to set them for all cels?
        Can collisions test and resolve within update? I think the testing is, it's just kind of convoluted.
        Reevaluate recursive collision and movement system.
          How should notifications work? I could also use a notify ID system for collision resolution instead but then IDs have to be unique which isn't bad. Might be nice instead of the hierarchy which is a little strange. Do I want this lookup over recursion? I could present and size by single entity only then!
        This decamillipixel nonsense is confusing. It's like .1px/s but everything is .6px/s or more. Is the half pixel needed? Millipixel would be a lot nicer. This would be more forgiving for the shader shorts. What's going on in vertex.glsl?
        Maybe base Entity should support targeting. Entities often have a destination.
        Consider alternative rain shader patterns.
        Develop entity behaviors (AI) more. The circle bee behavior might be a good starting point.
        Add some kind of unstoppable giant monster / colossus / death entity.
        The s/getter syntax is terser but isn't very flexible compared to functions: 1) no support for multiple parameters 2) types must match 3) creates ambiguity with functions 4) for better and worse, allows implicit conversions via duck typing 5) abstracts properties as functions which can work well for otherwise plain data types but similarly creates confusion for fixed mutation / copy methods. Should I change them to functions?
  Synthesize fantastic sounds.
    Understand the basics: https://news.ycombinator.com/item?id=20272346
    Rename audio player to speaker or something.
    Flesh out the audio system.
      Synthesize crickets, wind, rain, thunder, and birds.
    Survey all the demos in Super Collider.
    Probably pursue lofi.
  Improve the structure. Write little, clearly.
    What TypeScript and other open source examples should I consider?
    Re-review WebGL implementations.
  Add windy grass displacement shader to make the fields pop.
    Can I do large fields of windy grass either with a shader or an animation or both? I think this would be invaluable to the atmosphere quality of the game. Some examples in map3.aseprite.
    Improve the foreground and background coloring of grass clumps. Some nice examples in map5.aseprite.
    Maybe look through shader toys and displacement shader 101s.
      https://forums.tigsource.com/index.php?topic=40539.20
      https://www.austinobrien.me/blog/shader-study/slime-rancher-pixel-display
    Add shadow distortion shader too.
    Do I need a shader for better types of water? What does it look like?
  How can I move my planning materials into the VCS?
  Review Diablo tile IDs: https://www.boristhebrave.com/2019/07/14/dungeon-generation-in-diablo-1/
  Improve favicon.
  Add performance test level.
  Add test for newing each entity variant.
  Set up natureelsewhere.com GitHub page. Point to demo at ne.netlify.com.
  Set up oddoid.com GitHub page. Point to natureelsewhere.com and other projects.
  Evaluate fixing known issues in readme.
    If I drop WebGL v2, drop @types/webgl2.
  What examples are there for making 9png like UI?
    Check out 9pngs / 9patch and svgs like https://twitter.com/rchrdnsh/status/1155163594264203264  https://thebookofshaders.com/09/
  Research videos and articles by the experts like GDC.
  Extract the natural engine to a distributable package
  Enums are serializing their keys or their bits: 1) the mechanism should probably be consistent 2) either the keys or the bits can't change; with string enums it felt more flexible since the value string was a more abstract thing than a specific power of two, for example.
  Do I want to support sublevels like caves, pits, and houses?
  Add moon level. See moon, satellite, and castle ruin from tileset-big.ase.
  Add Nature Elsewhere logo.
  On a multitouch, if you touch left and right sides of the screen at the same time, the player oscillates.
  Experiment with drawing the logo in multiple color and animation passes. The shader can be used or an animation.

aseprite-atlas
  Reconsider JSON serialization of infinite duration. If a special value like null or not present is used, either a parser for the parsed output or conditionals all over is needed.
  Keep thinking on OO tradeoffs.
mem-font
  Push mem-font changes upstream and rework project.
oddoid
  Keep thinking on names.
