use super::xy::XY;
use num::traits::{cast::NumCast, Zero};
use serde::Serialize;
use std::any::Any;
use std::{
  fmt,
  ops::{Add, AddAssign, Div, Mul, Sub},
};

// Todo:
// - Consolidate notes from plan.txt, nature-elsewhere.txt, and elsewhere into
//   todo, GDD, and version history.
// - Finish copying the stuff from old NE.
// - Move this to todo.md. Can I enable wrapping? Or do I want to keep plain
//   text + indent?
// - Figure out closure stuff and get running in browser. https://news.ycombinator.com/item?id=22108957
// - Add tests for each method (same for XY), verify empty and flipped are
//   handled and tested for each method.
// - Keep thinking on how to handle order() better. This would be an invalid
//   state if assumed, or at least returns very surprising results, I think.
//   Back-facing rectangle can collide with front facing point that's in a
//   different location, for example. I could only expose try_intersection() and
//   limit min / max access to readonly methods. Is the flipped rectangle useful
//   for something else? When it predictably describes the rectangle between a
//   failed intersection, maybe. Review encumber follies. A flipped rectangle
//   could also be a new type that is generated by a factory constructor that
//   validates *all* mutations (e.g., multiply by XY which can flip it).
// - I think the `where` style of constraints per function is superior to adding
//   them to the impl. Make that consistent throughout hte project.
// - Am I using `try_into()` and `?` instead of `into().unwrap()` consistently?
// - Add to readme: the Cargo workflow doesn't seem too flexible for shoehorning
//   Bash scripts. Some folks use xtasks but that's too complex. I just NPM
//   since I need it for Wasm things and make the entry point.
// - Add platform OpenGL support via glow and such. Review the Roguelike setup
//   for this. Try to featurize the platforms into different configs.
// - Update note on terse naming like wh (instead of size), xy (instead of
//   position), and R16 (instead of rectangle). Make sure using these
//   abbreviations consistently and not overdoing it either.
// - Add to readme: NE is now a strange mix of Rust and JavaScript / Wasm, most
//   evident at the seams of the HAL / browser and the package managers (NPM,
//   Cargo), and the _copious_ output form Rust tooling.
// - Consider more `T::from(2).unwrap()` like generic code instead of macros.
// - Review all the Clone / Copy and reference / value usages.
// - Review derive style. Should struct and enums be consistently deriving?
// - Finish Rust book. Left off here: https://doc.rust-lang.org/book/ch10-01-syntax.html.
// - Read Rust roguelike tutorial + SDK: https://bfnightly.bracketproductions.com/rustbook/chapter_0.html.
// - Keep review Rust references:
//   - https://doc.rust-lang.org/stable/std/option/enum.Option.html
//   - https://tomassedovic.github.io/roguelike-tutorial/
//   - Other Rust game tutorials?
//   - https://nest.pijul.com/pijul_org/pijul:master/bc6ef4dc95092c70da32#YnMQ5z2CHHy
//   - https://github.com/Canop/broot/blob/master/src/shell_install/bash.rs
//   - https://github.com/rust-lang/rust
//   - https://github.com/servo/euclid
//   - https://serde.rs/attr-default.html, https://serde.rs/field-attrs.html
//   - https://github.com/maxbittker/sandspiel
//   - https://github.com/parasyte/pixels
//   - https://github.com/PistonDevelopers/texture_packer
//   - https://www.chinedufn.com/3d-webgl-basic-water-tutorial/
//   - https://github.com/BurntSushi/byteorder/blob/master/src/io.rs
//   - https://livebook.manning.com/book/rust-in-action
// - Review saturating_add() usages and overflow potentials in wrap and ceil
//   especially.
// - Review encumber and consider rectangle packing and inven.
// - Do I want to use min / max instead of from / to terminology? On one hand,
//   it's clearer when true but it's never true for a failed intersection test,
//   for example, which occurs often. I do like hte front/back-facing
//   terminology.
// - Version docs and history in web repo and set up DNS and verify n.com. This
//   will be fun and easy and mindless. Write a script that can npm i &&
//   npm build each commit to a new directory + zip. whatever the products I
//   need are. Same for oddoid.com which sould just link to ne.com.
// - Should GDD be a separate repo? Will I have many images? I can't put
//   copyrighted sources in it so maybe that needs to be a separate document
//   just for inspirado.
// https://specs.amethyst.rs/docs/tutorials/11_advanced_component.html
// https://docs.rs/specs/0.16.1/specs/trait.Component.html
// https://github.com/rust-lang-nursery/lazy-static.rs
// https://docs.serde.rs/serde_json/macro.json.html
// https://serde.rs/field-attrs.html

/// Axis-aligned rectangle. Rectangles are considered front-facing when both
/// components of `from` are less-than or equal to `to` and back-facing
/// (flipped) otherwise. Back-facing rectangles are useful for distinguishing
/// certain states such as the intersection of disjoint rectangles. Rect itself
/// makes no distinction between back- and front-facing rectangles except for
/// `Rect.flipped()`. A back-facing rectangle can be recomputed to a
/// front-facing rectangle by calling order().
#[derive(Clone, Eq, PartialEq, Serialize)]
pub struct Rect<T: Any + Send + Sync + Default> {
  pub from: XY<T>,
  pub to: XY<T>,
}
pub type R16 = Rect<i16>;

impl<T: Any + Default + Send + Sync> Rect<T> {
  pub fn new(fx: T, fy: T, tx: T, ty: T) -> Self {
    Self { from: XY::new(fx, fy), to: XY::new(tx, ty) }
  }

  pub fn new_wh(fx: T, fy: T, w: T, h: T) -> Self
  where
    T: Add<Output = T> + Clone,
  {
    Self { from: XY::new(fx.clone(), fy.clone()), to: XY::new(fx + w, fy + h) }
  }

  /// Cast each component passed and returns a new Rect.
  pub fn try_from<From>(fx: From, fy: From, tx: From, ty: From) -> Option<Self>
  where
    From: NumCast,
    T: NumCast,
  {
    Some(Self { from: XY::try_from(fx, fy)?, to: XY::try_from(tx, ty)? })
  }

  pub fn try_from_wh<From, To>(fx: From, fy: From, w: To, h: To) -> Option<Self>
  where
    T: Add<Output = T> + NumCast + Clone,
    From: NumCast,
    To: NumCast,
  {
    let from = XY::try_from(fx, fy)?;
    Some(Self { to: from.clone() + XY::try_from(w, h)?, from })
  }

  /// Cast each component of self and returns a new Rect.
  pub fn try_into<Into: Any + Default + Send + Sync>(self) -> Option<Rect<Into>>
  where
    T: NumCast,
    Into: NumCast,
  {
    Some(Rect { from: self.from.try_into()?, to: self.to.try_into()? })
  }

  pub fn wh(&self) -> XY<T>
  where
    T: Sub<Output = T> + Ord + Copy,
  {
    self.max() - self.min()
  }

  pub fn width(&self) -> T
  where
    T: Sub<Output = T> + Ord + Copy,
  {
    self.wh().x
  }

  pub fn height(&self) -> T
  where
    T: Sub<Output = T> + Ord + Copy,
  {
    self.wh().y
  }

  pub fn area(&self) -> T
  where
    T: Sub<Output = T> + Mul<Output = T> + Ord + Copy,
  {
    self.wh().area()
  }

  pub fn empty(&self) -> bool
  where
    T: Sub<Output = T> + Mul<Output = T> + Zero + Ord + Copy,
  {
    let XY { x, y } = self.wh();
    x.is_zero() || y.is_zero()
  }

  /// Returns true if Rect is back-facing (from < to), false if front-facing.
  pub fn flipped(&self) -> bool
  where
    T: PartialOrd,
  {
    self.to.x < self.from.x || self.to.y < self.from.y
  }

  pub fn min(&self) -> XY<T>
  where
    T: Ord + Copy,
  {
    self.from.min(&self.to)
  }

  pub fn max(&self) -> XY<T>
  where
    T: Ord + Copy,
  {
    self.from.max(&self.to)
  }

  /// Returns a new front-facing Rect range with coordinates reordered such that
  /// from <= to.
  pub fn order(&self) -> Self
  where
    T: Ord + Copy,
  {
    Self { from: self.min(), to: self.max() }
  }

  /// Return true if self and rhs are overlapping, false if touching or
  /// independent.
  pub fn intersects(&self, rhs: &Self) -> bool
  where
    T: Ord + Copy,
  {
    let lhs = self.order();
    let rhs = rhs.order();
    lhs.from.x < rhs.to.x
      && lhs.to.x > rhs.from.x
      && lhs.from.y < rhs.to.y
      && lhs.to.y > rhs.from.y
  }

  /// from > to if no intersection, from == to if touching but not overlapping,
  /// or from < to if overlapping.
  pub fn intersection(&self, rhs: &Self) -> Self
  where
    T: Ord + Copy,
  {
    // what about empties?
    let lhs = self.order();
    let rhs = rhs.order();
    Self { from: lhs.from.max(&rhs.from), to: lhs.to.min(&rhs.to) }
  }

  pub fn union(&self, rhs: &Self) -> Self
  where
    T: Ord + Copy,
  {
    // what about empties?
    let lhs = self.order();
    let rhs = rhs.order();
    Self { from: lhs.from.min(&rhs.from), to: lhs.to.max(&rhs.to) }
  }

  pub fn try_intersection(&self, rhs: &Self) -> Result<Self, Self>
  where
    T: Sub<Output = T> + Mul<Output = T> + Ord + Zero + Copy,
  {
    let intersection = self.intersection(rhs);
    if intersection.flipped() || intersection.empty() {
      return Err(intersection);
    }
    Ok(intersection)
  }

  pub fn union_all(rects: &[Self]) -> Option<Self>
  where
    T: Sub<Output = T> + Mul<Output = T> + Ord + Zero + Copy,
  {
    if rects.is_empty() {
      return None;
    }
    let union =
      rects.iter().fold(rects[0].clone(), |sum, rect| sum.union(rect));
    if union.empty() {
      return None;
    }
    Some(union)
  }

  pub fn center(&self) -> XY<T>
  where
    T: Add<Output = T> + Sub<Output = T> + Div<Output = T> + NumCast + Copy,
  {
    self.from.clone()
      + (self.to.clone() - self.from.clone())
        / T::from(2)
          .expect(&format!("Conversion from i32 to {} failed.", stringify!(T)))
  }
}

macro_rules! impl_magnitude {
  ($($t:ty),*) => ($(
    impl Rect<$t> {
      pub fn magnitude(&self) -> $t {
        (self.from.clone() - self.to.clone()).magnitude()
      }
    }
  )*)
}
impl_magnitude!(u8, i8, u16, i16, u32, i32, f32, u64, i64, f64, usize, isize);

impl<T: fmt::Debug + Any + Default + Send + Sync> fmt::Debug for Rect<T> {
  fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(formatter, "[{:?}, {:?}]", self.from, self.to)
  }
}

impl<T: fmt::Display + Any + Default + Send + Sync> fmt::Display for Rect<T> {
  fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(formatter, "[{}, {}]", self.from, self.to)
  }
}

impl<T: Add<Output = T> + Any + Default + Send + Sync> Add<Rect<T>>
  for Rect<T>
{
  type Output = Self;

  fn add(self, rhs: Self) -> Self {
    Self { from: self.from + rhs.from, to: self.to + rhs.to }
  }
}

impl<T: Add<Output = T> + Clone + Default + Any + Send + Sync> Add<XY<T>>
  for Rect<T>
{
  type Output = Self;

  fn add(self, rhs: XY<T>) -> Self {
    Self { from: self.from + rhs.clone(), to: self.to + rhs }
  }
}

impl<T: AddAssign + Any + Default + Send + Sync + Clone> AddAssign<&XY<T>>
  for Rect<T>
{
  fn add_assign(&mut self, rhs: &XY<T>) {
    self.from += rhs.clone();
    self.to += rhs.clone();
  }
}

impl<T: Sub<Output = T> + Any + Default + Send + Sync> Sub<Rect<T>>
  for Rect<T>
{
  type Output = Self;

  fn sub(self, rhs: Self) -> Self {
    Self { from: self.from - rhs.from, to: self.to - rhs.to }
  }
}

impl<T: Sub<Output = T> + Clone + Any + Default + Send + Sync> Sub<XY<T>>
  for Rect<T>
{
  type Output = Self;

  fn sub(self, rhs: XY<T>) -> Self {
    Self { from: self.from - rhs.clone(), to: self.to - rhs }
  }
}

impl<T: Mul<Output = T> + Any + Default + Send + Sync> Mul<Rect<T>>
  for Rect<T>
{
  type Output = Self;

  fn mul(self, rhs: Self) -> Self {
    Self { from: self.from * rhs.from, to: self.to * rhs.to }
  }
}

impl<T: Mul<Output = T> + Clone + Any + Default + Send + Sync> Mul<XY<T>>
  for Rect<T>
{
  type Output = Self;

  fn mul(self, rhs: XY<T>) -> Self {
    Self { from: self.from * rhs.clone(), to: self.to * rhs }
  }
}

impl<T: Div<Output = T> + Any + Default + Send + Sync> Div<Rect<T>>
  for Rect<T>
{
  type Output = Self;

  fn div(self, rhs: Self) -> Self {
    Self { from: self.from / rhs.from, to: self.to / rhs.to }
  }
}

impl<T: Div<Output = T> + Clone + Any + Default + Send + Sync> Div<XY<T>>
  for Rect<T>
{
  type Output = Self;

  fn div(self, rhs: XY<T>) -> Self {
    Self { from: self.from / rhs.clone(), to: self.to / rhs }
  }
}

pub trait Contains<T> {
  fn contains(&self, rhs: &T) -> bool;
}

impl<
    T: Sub<Output = T>
      + Mul<Output = T>
      + Ord
      + Zero
      + Copy
      + Any
      + Default
      + Send
      + Sync,
  > Contains<Rect<T>> for Rect<T>
{
  /// Return true if rhs fits within possibly touching but not overlapping.
  fn contains(&self, rhs: &Self) -> bool {
    if self.empty() {
      return false;
    }
    let lhs = self.order();
    let rhs = rhs.order();
    lhs.from.x <= rhs.from.x
      && lhs.to.x >= rhs.to.x
      && lhs.from.y <= rhs.from.y
      && lhs.to.y >= rhs.to.y
  }
}

impl<T: Ord + Copy + Any + Default + Send + Sync> Contains<XY<T>> for Rect<T> {
  fn contains(&self, &XY { x, y }: &XY<T>) -> bool {
    let lhs = self.order();
    x < lhs.to.x && x > lhs.from.x && y < lhs.to.y && y > lhs.from.y
  }
}

pub trait CenterOn<T> {
  /// Return true if self and rhs are overlapping, false if touching or
  /// independent.
  fn center_on(&self, on: &T) -> Self;
}

impl<
    T: Add<Output = T>
      + Sub<Output = T>
      + Div<Output = T>
      + NumCast
      + Copy
      + Any
      + Default
      + Send
      + Sync,
  > CenterOn<Rect<T>> for Rect<T>
{
  fn center_on(&self, on: &Self) -> Rect<T> {
    self.center_on(&on.center())
  }
}

impl<
    T: Add<Output = T>
      + Sub<Output = T>
      + Div<Output = T>
      + NumCast
      + Copy
      + Any
      + Default
      + Send
      + Sync,
  > CenterOn<XY<T>> for Rect<T>
{
  fn center_on(&self, on: &XY<T>) -> Rect<T> {
    let mv = on.clone() - self.center();
    Self { from: self.from.clone() + mv.clone(), to: self.to.clone() + mv }
  }
}

#[cfg(test)]
mod test {
  use super::*;

  #[test]
  fn new() {
    assert_eq!(
      Rect::new(1, 2, 3, 4),
      R16 { from: XY { x: 1, y: 2 }, to: XY { x: 3, y: 4 } }
    )
  }

  #[test]
  fn new_wh() {
    assert_eq!(
      Rect::new_wh(1, 2, 3, 4),
      R16 { from: XY { x: 1, y: 2 }, to: XY { x: 4, y: 6 } }
    )
  }

  #[test]
  fn try_from() {
    assert_eq!(
      Rect::try_from(1.2, 3.4, 5.6, 7.8).unwrap(),
      R16 { from: XY { x: 1, y: 3 }, to: XY { x: 5, y: 7 } }
    )
  }

  #[test]
  fn try_into() {
    assert_eq!(
      Rect::<f64> { from: XY { x: 1.2, y: 3.4 }, to: XY { x: 5.6, y: 7.8 } }
        .try_into()
        .unwrap(),
      R16 { from: XY { x: 1, y: 3 }, to: XY { x: 5, y: 7 } }
    )
  }

  #[test]
  fn add_rect() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 2 }, to: XY { x: 3, y: 4 } }
        + Rect { from: XY { x: 5, y: 6 }, to: XY { x: 7, y: 8 } },
      Rect { from: XY { x: 6, y: 8 }, to: XY { x: 10, y: 12 } }
    )
  }

  #[test]
  fn add_xy() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 2 }, to: XY { x: 3, y: 4 } }
        + XY { x: 5, y: 6 },
      Rect { from: XY { x: 6, y: 8 }, to: XY { x: 8, y: 10 } }
    )
  }

  #[test]
  fn sub_rect() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 2 }, to: XY { x: 3, y: 4 } }
        - Rect { from: XY { x: 5, y: 6 }, to: XY { x: 7, y: 8 } },
      Rect { from: XY { x: -4, y: -4 }, to: XY { x: -4, y: -4 } }
    )
  }

  #[test]
  fn sub_xy() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 2 }, to: XY { x: 3, y: 4 } }
        - XY { x: 5, y: 6 },
      Rect { from: XY { x: -4, y: -4 }, to: XY { x: -2, y: -2 } }
    )
  }

  #[test]
  fn mul_rect() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 2 }, to: XY { x: 3, y: 4 } }
        * Rect { from: XY { x: 5, y: 6 }, to: XY { x: 7, y: 8 } },
      Rect { from: XY { x: 5, y: 12 }, to: XY { x: 21, y: 32 } }
    )
  }

  #[test]
  fn mul_xy() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 2 }, to: XY { x: 3, y: 4 } }
        * XY { x: 5, y: 6 },
      Rect { from: XY { x: 5, y: 12 }, to: XY { x: 15, y: 24 } }
    )
  }

  #[test]
  fn div_rect() {
    assert_eq!(
      Rect { from: XY { x: 5, y: 6 }, to: XY { x: 7, y: 8 } }
        / Rect { from: XY { x: 1, y: 2 }, to: XY { x: 3, y: 4 } },
      Rect { from: XY { x: 5, y: 3 }, to: XY { x: 2, y: 2 } }
    )
  }

  #[test]
  fn div_xy() {
    assert_eq!(
      Rect { from: XY { x: 6, y: 5 }, to: XY { x: 4, y: 3 } }
        / XY { x: 2, y: 1 },
      Rect { from: XY { x: 3, y: 5 }, to: XY { x: 2, y: 3 } }
    )
  }

  #[test]
  fn wh() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 2 }, to: XY { x: 3, y: 4 } }.wh(),
      XY { x: 2, y: 2 }
    )
  }

  #[test]
  fn area() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 2 }, to: XY { x: 3, y: 4 } }.area(),
      4
    )
  }

  #[test]
  fn empty_zero() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 1 }, to: XY { x: 5, y: 1 } }.empty(),
      true
    )
  }

  #[test]
  fn empty_nonzero() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 1 }, to: XY { x: 5, y: 5 } }.empty(),
      false
    )
  }

  #[test]
  fn magnitude() {
    assert_eq!(
      R16 { from: XY { x: 1, y: 2 }, to: XY { x: 4, y: 6 } }.magnitude(),
      5
    )
  }

  #[test]
  fn min() {
    assert_eq!(
      Rect { from: XY { x: 4, y: 1 }, to: XY { x: 2, y: 3 } }.min(),
      XY { x: 2, y: 1 }
    )
  }

  #[test]
  fn max() {
    assert_eq!(
      Rect { from: XY { x: 4, y: 1 }, to: XY { x: 2, y: 3 } }.max(),
      XY { x: 4, y: 3 }
    )
  }

  #[test]
  fn order() {
    assert_eq!(
      Rect { from: XY { x: 4, y: 1 }, to: XY { x: 2, y: 3 } }.order(),
      Rect { from: XY { x: 2, y: 1 }, to: XY { x: 4, y: 3 } }
    )
  }

  #[test]
  fn contains_xy_external() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 1 }, to: XY { x: 4, y: 4 } }
        .contains(&XY { x: 5, y: 5 }),
      false
    )
  }

  #[test]
  fn contains_xy_internal() {
    assert_eq!(
      Rect { from: XY { x: 1, y: 1 }, to: XY { x: 4, y: 4 } }
        .contains(&XY { x: 2, y: 2 }),
      true
    )
  }

  // (diagram, lhs, rhs, intersects, contains, intersection, union)
  const CASES: &[(&str, R16, R16, bool, bool, R16, R16)] = &[
    (
      "
        0   │    Overlapping Square
          ┌─╆━┱─┐
        ──┼─╂L╂R┼
          └─╄━┹─┘
            │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 0, y: -1 }, to: XY { x: 2, y: 1 } },
      true,
      false,
      Rect { from: XY { x: 0, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 2, y: 1 } },
    ),
    (
      "
        1   ├───┐Overlapping Square
          ┌─╆━┓R│
        ──┼─╄L╃─┴
          └─┼─┘
            │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 0, y: -2 }, to: XY { x: 2, y: 0 } },
      true,
      false,
      Rect { from: XY { x: 0, y: -1 }, to: XY { x: 1, y: 0 } },
      Rect { from: XY { x: -1, y: -2 }, to: XY { x: 2, y: 1 } },
    ),
    (
      "
        2 ┌─R─┐  Overlapping Square
          ┢━┿━┪
        ──┡━┿L┩──
          └─┼─┘
            │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -2 }, to: XY { x: 1, y: 0 } },
      true,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 0 } },
      Rect { from: XY { x: -1, y: -2 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        3───┤    Overlapping Square
        │R┏━╅─┐
        ┴─╄━╃L┼──
          └─┼─┘
            │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -2, y: -2 }, to: XY { x: 0, y: 0 } },
      true,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 0, y: 0 } },
      Rect { from: XY { x: -2, y: -2 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        4   │    Overlapping Square
        ┌─┲━╅─┐
        ┼R╂─╂L┼──
        └─┺━╃─┘
            │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -2, y: -1 }, to: XY { x: 0, y: 1 } },
      true,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 0, y: 1 } },
      Rect { from: XY { x: -2, y: -1 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        5   │    Overlapping Square
          ┌─┼─┐
        ┬─╆━╅L┼──
        │R┗━╃─┘
        └───┤
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -2, y: 0 }, to: XY { x: 0, y: 2 } },
      true,
      false,
      Rect { from: XY { x: -1, y: 0 }, to: XY { x: 0, y: 1 } },
      Rect { from: XY { x: -2, y: -1 }, to: XY { x: 1, y: 2 } },
    ),
    (
      "
        6   │    Overlapping Square
          ┌─┼─┐
        ──╆━┿L╅──
          ┡━┿━┩
          └─R─┘
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: 0 }, to: XY { x: 1, y: 2 } },
      true,
      false,
      Rect { from: XY { x: -1, y: 0 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 2 } },
    ),
    (
      "
        7   │    Overlapping Square
          ┌─┼─┐
        ──┼─╆L╅─┬
          └─╄━┛R│
            ├───┘
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: 2, y: 2 } },
      true,
      false,
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 2, y: 2 } },
    ),
    (
      "
        0 ┌───┼───┐Overlapping Oblong
          │ ┏━┿━┓R│
          └─╄━┿━╃─┘
        ────┼─┼L┼────
            │ │ │
            └─┼─┘
              │
      ",
      Rect { from: XY { x: -1, y: -2 }, to: XY { x: 1, y: 2 } },
      Rect { from: XY { x: -2, y: -3 }, to: XY { x: 2, y: -1 } },
      true,
      false,
      Rect { from: XY { x: -1, y: -2 }, to: XY { x: 1, y: -1 } },
      Rect { from: XY { x: -2, y: -3 }, to: XY { x: 2, y: 2 } },
    ),
    (
      "
        1     │    Overlapping Oblong
            ┌─┼─┐
          ┌─╆━┿━┪─┐
        ──┼─╂─┼L╂R┼──
          └─╄━┿━╃─┘
            └─┼─┘
              │
      ",
      Rect { from: XY { x: -1, y: -2 }, to: XY { x: 1, y: 2 } },
      Rect { from: XY { x: -2, y: -1 }, to: XY { x: 2, y: 1 } },
      true,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -2, y: -2 }, to: XY { x: 2, y: 2 } },
    ),
    (
      "
        2     │    Overlapping Oblong
            ┌─┼─┐
            │ │ │
        ────┼─┼L┼────
          ┌─╆━┿━┪─┐
          │ ┗━┿━┛R│
          └───┼───┘
      ",
      Rect { from: XY { x: -1, y: -2 }, to: XY { x: 1, y: 2 } },
      Rect { from: XY { x: -2, y: 1 }, to: XY { x: 2, y: 3 } },
      true,
      false,
      Rect { from: XY { x: -1, y: 1 }, to: XY { x: 1, y: 2 } },
      Rect { from: XY { x: -2, y: -2 }, to: XY { x: 2, y: 3 } },
    ),
    (
      "
        ┌────┼───┐Island
        │┏━┓ │   │
        │┃R┃ │   │
        │┗━┛ │ L │
        ┼────┼───┼
        └────┼───┘
      ",
      Rect { from: XY { x: -3, y: -4 }, to: XY { x: 2, y: 1 } },
      Rect { from: XY { x: -2, y: -3 }, to: XY { x: -1, y: -1 } },
      true,
      true,
      Rect { from: XY { x: -2, y: -3 }, to: XY { x: -1, y: -1 } },
      Rect { from: XY { x: -3, y: -4 }, to: XY { x: 2, y: 1 } },
    ),
    (
      "
          │Identical
          ┏━┿━┓
        ──╂R┼L╂──
          ┗━┿━┛
            │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      true,
      true,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
            │Empty
            │
        ────┼────
            │
            │
      ",
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: 0, y: 0 } },
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: 0, y: 0 } },
      false,
      false,
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: 0, y: 0 } },
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: 0, y: 0 } },
    ),
    (
      "
        0     │      Touching
              │
            ┌─┼─┰───┐
        ────┼─┼L╂──R┼
            └─┼─┸───┘
              │
              │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 1, y: -1 }, to: XY { x: 3, y: 1 } },
      false,
      false,
      Rect { from: XY { x: 1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 3, y: 1 } },
    ),
    (
      "
        1     │      Touching
              │ ┌───┐
            ┌─┼─┧  R│
        ────┼─┼L╀───┴
            └─┼─┘
              │
              │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 1, y: -2 }, to: XY { x: 3, y: 0 } },
      false,
      false,
      Rect { from: XY { x: 1, y: -1 }, to: XY { x: 1, y: 0 } },
      Rect { from: XY { x: -1, y: -2 }, to: XY { x: 3, y: 1 } },
    ),
    (
      "
        2     │ ┌───┐Touching
              │ │  R│
            ┌─┼─┼───┘
        ────┼─┼L┼────
            └─┼─┘
              │
              │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 1, y: -3 }, to: XY { x: 3, y: -1 } },
      false,
      false,
      Rect { from: XY { x: 1, y: -1 }, to: XY { x: 1, y: -1 } },
      Rect { from: XY { x: -1, y: -3 }, to: XY { x: 3, y: 1 } },
    ),
    (
      "
        3     ├───┐Touching
              │  R│
            ┌─┾━┭─┘
        ────┼─┼L┼────
            └─┼─┘
              │
              │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 0, y: -3 }, to: XY { x: 2, y: -1 } },
      false,
      false,
      Rect { from: XY { x: 0, y: -1 }, to: XY { x: 1, y: -1 } },
      Rect { from: XY { x: -1, y: -3 }, to: XY { x: 2, y: 1 } },
    ),
    (
      "
        4   ┌─┼─┐    Touching
            │ │R│
            ┝━┿━┥
        ────┼─┼L┼───
            └─┼─┘
              │
              │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -3 }, to: XY { x: 1, y: -1 } },
      false,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: -1 } },
      Rect { from: XY { x: -1, y: -3 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        5 ┌───┼      Touching
          │  R│
          └─┮━┽─┐
        ────┼─┼L┼────
            └─┼─┘
              │
              │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -2, y: -3 }, to: XY { x: 0, y: -1 } },
      false,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 0, y: -1 } },
      Rect { from: XY { x: -2, y: -3 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        6───┐ │      Touching
        │  R│ │
        └───┼─┼─┐
        ────┼─┼L┼────
            └─┼─┘
              │
              │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -3, y: -3 }, to: XY { x: -1, y: -1 } },
      false,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: -1, y: -1 } },
      Rect { from: XY { x: -3, y: -3 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        7     │      Touching
        ┌───┐ │
        │  R┟─┼─┐
        ┴───╀─┼L┼───
            └─┼─┘
              │
              │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -3, y: -2 }, to: XY { x: -1, y: 0 } },
      false,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: -1, y: 0 } },
      Rect { from: XY { x: -3, y: -2 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        8     │      Touching
              │
        ┌───┰─┼─┐
        ┼──R╂─┼L┼───
        └───┸─┼─┘
              │
              │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -3, y: -1 }, to: XY { x: -1, y: 1 } },
      false,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: -1, y: 1 } },
      Rect { from: XY { x: -3, y: -1 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        9     │      Touching
              │
            ┌─┼─┐
        ┬───╁─┼L┼───
        │  R┞─┼─┘
        └───┘ │
              │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -3, y: 0 }, to: XY { x: -1, y: 2 } },
      false,
      false,
      Rect { from: XY { x: -1, y: 0 }, to: XY { x: -1, y: 1 } },
      Rect { from: XY { x: -3, y: -1 }, to: XY { x: 1, y: 2 } },
    ),
    (
      "
        10    │      Touching
              │
            ┌─┼─┐
        ────┼─┼L┼────
        ┌───┼─┼─┘
        │  R│ │
        └───┘ │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -3, y: 1 }, to: XY { x: -1, y: 3 } },
      false,
      false,
      Rect { from: XY { x: -1, y: 1 }, to: XY { x: -1, y: 1 } },
      Rect { from: XY { x: -3, y: -1 }, to: XY { x: 1, y: 3 } },
    ),
    (
      "
        11    │      Touching
              │
            ┌─┼─┐
        ────┼─┼L┼────
          ┌─┶━┽─┘
          │  R│
          └───┤
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -2, y: 1 }, to: XY { x: 0, y: 3 } },
      false,
      false,
      Rect { from: XY { x: -1, y: 1 }, to: XY { x: 0, y: 1 } },
      Rect { from: XY { x: -2, y: -1 }, to: XY { x: 1, y: 3 } },
    ),
    (
      "
        12    │      Touching
              │
            ┌─┼─┐
        ────┼─┼L┼───
            ┝━┿━┥
            │ │R│
            └─┼─┘
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: 1 }, to: XY { x: 1, y: 3 } },
      false,
      false,
      Rect { from: XY { x: -1, y: 1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 3 } },
    ),
    (
      "
        13    │      Touching
              │
            ┌─┼─┐
        ────┼─┼L┼────
            └─┾━┵─┐
              │  R│
              ├───┘
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 0, y: 1 }, to: XY { x: 2, y: 3 } },
      false,
      false,
      Rect { from: XY { x: 0, y: 1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 2, y: 3 } },
    ),
    (
      "
        14    │      Touching
              │
            ┌─┼─┐
        ────┼─┼L┼────
            └─┼─┼───┐
              │ │  R│
              │ └───┘
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 1, y: 1 }, to: XY { x: 3, y: 3 } },
      false,
      false,
      Rect { from: XY { x: 1, y: 1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 3, y: 3 } },
    ),
    (
      "
        15    │      Touching
              │
            ┌─┼─┐
        ────┼─┼L╁───┬
            └─┼─┦  R│
              │ └───┘
              │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 1, y: 0 }, to: XY { x: 3, y: 2 } },
      false,
      false,
      Rect { from: XY { x: 1, y: 0 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 3, y: 2 } },
    ),
    (
      "
        0      │    Disjoint
               │
               │
             ┌─┼─┐┌───┐
        ─────┼─┼L┼┼──R┼
             └─┼─┘└───┘
               │
               │
               │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 2, y: -1 }, to: XY { x: 4, y: 1 } },
      false,
      false,
      Rect { from: XY { x: 2, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 4, y: 1 } },
    ),
    (
      "
        1      │    Disjoint
               │
               │  ┌───┐
             ┌─┼─┐│  R│
        ─────┼─┼L┼┴───┴
             └─┼─┘
               │
               │
               │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 2, y: -2 }, to: XY { x: 4, y: 0 } },
      false,
      false,
      Rect { from: XY { x: 2, y: -1 }, to: XY { x: 1, y: 0 } },
      Rect { from: XY { x: -1, y: -2 }, to: XY { x: 4, y: 1 } },
    ),
    (
      "
        2      ├───┐Disjoint
               │  R│
               ├───┘
             ┌─┼─┐
        ─────┼─┼L┼─────
             └─┼─┘
               │
               │
               │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 0, y: -4 }, to: XY { x: 2, y: -2 } },
      false,
      false,
      Rect { from: XY { x: 0, y: -1 }, to: XY { x: 1, y: -2 } },
      Rect { from: XY { x: -1, y: -4 }, to: XY { x: 2, y: 1 } },
    ),
    (
      "
        3    ┌─┼─┐  Disjoint
             │ │R│
             └─┼─┘
             ┌─┼─┐
        ─────┼─┼L┼─────
             └─┼─┘
               │
               │
               │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -4 }, to: XY { x: 1, y: -2 } },
      false,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: -2 } },
      Rect { from: XY { x: -1, y: -4 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        4  ┌───┤    Disjoint
           │  R│
           └───┤
             ┌─┼─┐
        ─────┼─┼L┼─────
             └─┼─┘
               │
               │
               │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -2, y: -4 }, to: XY { x: 0, y: -2 } },
      false,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 0, y: -2 } },
      Rect { from: XY { x: -2, y: -4 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        5      │    Disjoint
               │
        ┌───┐  │
        │  R│┌─┼─┐
        ┴───┴┼─┼L┼─────
             └─┼─┘
               │
               │
               │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -4, y: -2 }, to: XY { x: -2, y: 0 } },
      false,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: -2, y: 0 } },
      Rect { from: XY { x: -4, y: -2 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        6      │    Disjoint
               │
               │
        ┌───┐┌─┼─┐
        ┼──R┼┼─┼L┼─────
        └───┘└─┼─┘
               │
               │
               │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -4, y: -1 }, to: XY { x: -2, y: 1 } },
      false,
      false,
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: -2, y: 1 } },
      Rect { from: XY { x: -4, y: -1 }, to: XY { x: 1, y: 1 } },
    ),
    (
      "
        7      │    Disjoint
               │
               │
             ┌─┼─┐
        ┬───┬┼─┼L┼─────
        │  R│└─┼─┘
        └───┘  │
               │
               │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -4, y: 0 }, to: XY { x: -2, y: 2 } },
      false,
      false,
      Rect { from: XY { x: -1, y: 0 }, to: XY { x: -2, y: 1 } },
      Rect { from: XY { x: -4, y: -1 }, to: XY { x: 1, y: 2 } },
    ),
    (
      "
        8      │    Disjoint
               │
               │
             ┌─┼─┐
        ─────┼─┼L┼─────
             └─┼─┘
           ┌───┤
           │  R│
           └───┤
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -2, y: 2 }, to: XY { x: 0, y: 4 } },
      false,
      false,
      Rect { from: XY { x: -1, y: 2 }, to: XY { x: 0, y: 1 } },
      Rect { from: XY { x: -2, y: -1 }, to: XY { x: 1, y: 4 } },
    ),
    (
      "
        9      │    Disjoint
               │
               │
             ┌─┼─┐
        ─────┼─┼L┼─────
             └─┼─┘
             ┌─┼─┐
             │ │R│
             └─┼─┘
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: 2 }, to: XY { x: 1, y: 4 } },
      false,
      false,
      Rect { from: XY { x: -1, y: 2 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 4 } },
    ),
    (
      "
        10     │    Disjoint
               │
               │
             ┌─┼─┐
        ─────┼─┼L┼─────
             └─┼─┘
               ├───┐
               │  R│
               ├───┘
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 0, y: 2 }, to: XY { x: 2, y: 4 } },
      false,
      false,
      Rect { from: XY { x: 0, y: 2 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 2, y: 4 } },
    ),
    (
      "
        11     │    Disjoint
               │
               │
             ┌─┼─┐
        ─────┼─┼L┼┬───┬
             └─┼─┘│  R│
               │  └───┘
               │
               │
      ",
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: 2, y: 0 }, to: XY { x: 4, y: 2 } },
      false,
      false,
      Rect { from: XY { x: 2, y: 0 }, to: XY { x: 1, y: 1 } },
      Rect { from: XY { x: -1, y: -1 }, to: XY { x: 4, y: 2 } },
    ),
    (
      "0 Distant Disjoint",
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: 10, y: 10 } },
      Rect { from: XY { x: 17, y: -22 }, to: XY { x: 25, y: -17 } },
      false,
      false,
      Rect { from: XY { x: 17, y: 0 }, to: XY { x: 10, y: -17 } },
      Rect { from: XY { x: 0, y: -22 }, to: XY { x: 25, y: 10 } },
    ),
    (
      "1 Distant Disjoint",
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: 10, y: 10 } },
      Rect { from: XY { x: -17, y: -22 }, to: XY { x: -9, y: -17 } },
      false,
      false,
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: -9, y: -17 } },
      Rect { from: XY { x: -17, y: -22 }, to: XY { x: 10, y: 10 } },
    ),
    (
      "2 Distant Disjoint",
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: 10, y: 10 } },
      Rect { from: XY { x: -17, y: 22 }, to: XY { x: -9, y: 27 } },
      false,
      false,
      Rect { from: XY { x: 0, y: 22 }, to: XY { x: -9, y: 10 } },
      Rect { from: XY { x: -17, y: 0 }, to: XY { x: 10, y: 27 } },
    ),
    (
      "3 Distant Disjoint",
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: 10, y: 10 } },
      Rect { from: XY { x: 17, y: 22 }, to: XY { x: 25, y: 27 } },
      false,
      false,
      Rect { from: XY { x: 17, y: 22 }, to: XY { x: 10, y: 10 } },
      Rect { from: XY { x: 0, y: 0 }, to: XY { x: 25, y: 27 } },
    ),
    (
      "0 Disparate Disjoint",
      Rect { from: XY { x: 100, y: 100 }, to: XY { x: 500, y: 1100 } },
      Rect { from: XY { x: 20, y: -39 }, to: XY { x: 32, y: -1 } },
      false,
      false,
      Rect { from: XY { x: 100, y: 100 }, to: XY { x: 32, y: -1 } },
      Rect { from: XY { x: 20, y: -39 }, to: XY { x: 500, y: 1100 } },
    ),
    (
      "1 Disparate Disjoint",
      Rect { from: XY { x: 100, y: 100 }, to: XY { x: 500, y: 1100 } },
      Rect { from: XY { x: -20, y: -39 }, to: XY { x: -8, y: -1 } },
      false,
      false,
      Rect { from: XY { x: 100, y: 100 }, to: XY { x: -8, y: -1 } },
      Rect { from: XY { x: -20, y: -39 }, to: XY { x: 500, y: 1100 } },
    ),
    (
      "2 Disparate Disjoint",
      Rect { from: XY { x: 100, y: 100 }, to: XY { x: 500, y: 1100 } },
      Rect { from: XY { x: -20, y: 39 }, to: XY { x: -8, y: 77 } },
      false,
      false,
      Rect { from: XY { x: 100, y: 100 }, to: XY { x: -8, y: 77 } },
      Rect { from: XY { x: -20, y: 39 }, to: XY { x: 500, y: 1100 } },
    ),
    (
      "3 Disparate Disjoint",
      Rect { from: XY { x: 100, y: 100 }, to: XY { x: 500, y: 1100 } },
      Rect { from: XY { x: 20, y: 39 }, to: XY { x: 32, y: 77 } },
      false,
      false,
      Rect { from: XY { x: 100, y: 100 }, to: XY { x: 32, y: 77 } },
      Rect { from: XY { x: 20, y: 39 }, to: XY { x: 500, y: 1100 } },
    ),
  ];

  #[test]
  fn intersects() {
    CASES.iter().enumerate().for_each(
      |(
        i,
        (diagram, lhs, rhs, intersects, _contains, _intersection, _union),
      )| {
        assert_eq!(
          lhs.intersects(rhs),
          *intersects,
          "Case {} failed: {:?}.{}",
          i,
          (lhs, rhs, intersects),
          diagram
        );
        assert_eq!(
          rhs.intersects(lhs),
          *intersects,
          "Case {} (flipped) failed: {:?}.{}",
          i,
          (lhs, rhs, intersects),
          diagram
        );
      },
    )
  }

  #[test]
  fn contains() {
    CASES.iter().enumerate().for_each(
      |(
        i,
        (diagram, lhs, rhs, _intersects, contains, _intersection, _union),
      )| {
        assert_eq!(
          lhs.contains(rhs),
          *contains,
          "Case {} failed: {:?}.{}",
          i,
          (lhs, rhs, contains),
          diagram
        );
      },
    )
  }

  #[test]
  fn intersection() {
    CASES.iter().enumerate().for_each(
      |(
        i,
        (diagram, lhs, rhs, _intersects, _contains, intersection, _union),
      )| {
        assert_eq!(
          lhs.intersection(rhs),
          *intersection,
          "Case {} failed: {:?}.{}",
          i,
          (lhs, rhs, intersection),
          diagram
        );
        assert_eq!(
          rhs.intersection(lhs),
          *intersection,
          "Case {} (flipped) failed: {:?}.{}",
          i,
          (lhs, rhs, intersection),
          diagram
        );
      },
    )
  }

  #[test]
  fn union() {
    CASES.iter().enumerate().for_each(
      |(
        i,
        (diagram, lhs, rhs, _intersects, _contains, _intersection, union),
      )| {
        assert_eq!(
          lhs.union(rhs),
          *union,
          "Case {} failed: {:?}.{}",
          i,
          (lhs, rhs, union),
          diagram
        );
        assert_eq!(
          rhs.union(lhs),
          *union,
          "Case {} (flipped) failed: {:?}.{}",
          i,
          (lhs, rhs, union),
          diagram
        );
      },
    )
  }
}
